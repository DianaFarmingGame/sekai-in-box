(defvar make_road (func [ref x_offset diverse]
	(make_define BlockStaticExt
		ref ref
		props {
			need_route #f
			routable #f
			need_collision #f
			collisible #f
			asserts {
				main "assert/è·¯.png"
			}
			cur_draw &
			draw_data {
				corner_nw [&static &main (clip_ground (+ x_offset 0) 0)]
				corner_ne [&static &main (clip_ground (+ x_offset 2) 0)]
				corner_se [&static &main (clip_ground (+ x_offset 2) 2)]
				corner_sw [&static &main (clip_ground (+ x_offset 0) 2)]
				side_n [&static &main (clip_ground (+ x_offset 1) 0)]
				side_e [&static &main (clip_ground (+ x_offset 2) 1)]
				side_s [&static &main (clip_ground (+ x_offset 1) 2)]
				side_w [&static &main (clip_ground (+ x_offset 0) 1)]
				center (if diverse
					[&diverse [
						[&static &main (clip_ground (+ x_offset 1) 1)]
						[&static &main (clip_ground (+ x_offset 0) 5)]
						[&static &main (clip_ground (+ x_offset 1) 5)]
					]]
					[&static &main (clip_ground (+ x_offset 1) 1)])
				concave_nw [&static &main (clip_ground (+ x_offset 0) 3)]
				concave_ne [&static &main (clip_ground (+ x_offset 1) 3)]
				concave_se [&static &main (clip_ground (+ x_offset 1) 4)]
				concave_sw [&static &main (clip_ground (+ x_offset 0) 4)]
				concaves_nw_se [&static &main (clip_ground (+ x_offset 2) 4)]
				concaves_ne_sw [&static &main (clip_ground (+ x_offset 2) 3)]
			}
			random_rules (if diverse
				[
					[1 { cover { cur_draw_variant 1 }}]
					[1 { cover { cur_draw_variant 2 }}]
					[3 {}]
				]
				[])
			atile_size (vec3 3 3 1)
			groups [ref]
			atile_matches [[ref]]
			atile_rules *atile_rules_3x3x1_crossed*
		})))

(sign_define (make_road 105 0 #f))
(sign_define (make_road 106 3 #t))
(sign_define (make_road 107 6 #f))
(sign_define (make_road 108 9 #t))
